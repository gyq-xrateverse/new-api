# New API 项目架构分析报告

## 项目概述

**New API** 是一个新一代大模型网关与AI资产管理系统，基于 [One API](https://github.com/songquanpeng/one-api) 项目进行二次开发。该项目的核心功能是**将多种大模型统一转换为标准格式调用**，实现了AI模型聚合管理中转分发系统。

---

## 一、整体架构设计

### 1.1 核心架构模式

项目采用 **适配器模式（Adapter Pattern）+ DTO模式** 实现多平台AI模型的统一接入：

```
用户请求 (OpenAI格式)
    ↓
[路由层 Router]
    ↓
[中间件层 Middleware] - 认证/限流/日志
    ↓
[控制器层 Controller] - 请求分发
    ↓
[中继层 Relay] - 核心转换逻辑
    ↓
[适配器层 Adaptor] - 各平台适配器
    ↓
AI服务提供商 (OpenAI/Claude/Gemini/阿里/...)
```

### 1.2 关键技术特点

1. **统一接口协议**：所有外部请求使用 OpenAI 格式作为标准
2. **双向转换机制**：支持请求和响应的双向转换
3. **可插拔适配器**：每个AI平台独立适配器，易于扩展
4. **异步任务支持**：图片/视频生成采用异步任务模式
5. **多格式输出**：支持转换为 OpenAI/Claude/Gemini 等格式

---

## 二、统一参数转换机制（DTO层）

### 2.1 DTO层设计理念

DTO（Data Transfer Object）层是实现统一格式的核心，所有请求首先转换为标准DTO结构：

#### **主要DTO结构**

| DTO类型 | 文件路径 | 用途 |
|---------|----------|------|
| `GeneralOpenAIRequest` | `dto/openai_request.go` | 文本对话统一请求 |
| `ImageRequest` | `dto/openai_image.go` | 图片生成统一请求 |
| `VideoRequest` | `dto/video.go` | 视频生成统一请求 |
| `ClaudeRequest` | `dto/claude.go` | Claude格式请求 |
| `GeminiChatRequest` | `dto/gemini.go` | Gemini格式请求 |

### 2.2 统一参数设计关键点

#### 2.2.1 **通用字段提取**

以 `GeneralOpenAIRequest` 为例（`dto/openai_request.go:25-90`）：

```go
type GeneralOpenAIRequest struct {
    Model               string            `json:"model,omitempty"`
    Messages            []Message         `json:"messages,omitempty"`
    Stream              bool              `json:"stream,omitempty"`
    MaxTokens           uint              `json:"max_tokens,omitempty"`
    Temperature         *float64          `json:"temperature,omitempty"`
    TopP                float64           `json:"top_p,omitempty"`
    TopK                int               `json:"top_k,omitempty"`
    Stop                any               `json:"stop,omitempty"`
    Tools               []ToolCallRequest `json:"tools,omitempty"`
    // ... 更多通用字段
}
```

**设计原则**：
- 包含所有主流AI平台的公共参数
- 使用 `json.RawMessage` 保留特殊字段
- 支持多媒体内容（图片/音频/视频）

#### 2.2.2 **扩展字段处理**

不同平台的特殊参数通过以下方式处理：

1. **预定义扩展字段**：如 `ExtraBody`, `Metadata`, `SearchParameters`
2. **动态字段接收**：使用 `Extra map[string]json.RawMessage`

示例（`dto/openai_image.go:31-60`）：

```go
type ImageRequest struct {
    Model      string          `json:"model"`
    Prompt     string          `json:"prompt"`
    // 标准字段
    Size       string          `json:"size,omitempty"`
    Quality    string          `json:"quality,omitempty"`
    // 扩展字段容器
    Extra      map[string]json.RawMessage `json:"-"`
}

// 自定义反序列化接收额外参数
func (i *ImageRequest) UnmarshalJSON(data []byte) error {
    // 分离已知字段和额外字段
}
```

### 2.3 多媒体内容统一表示

#### **Message 内容结构**（`dto/openai_request.go:271-293`）

```go
type Message struct {
    Role    string `json:"role"`
    Content any    `json:"content"` // 可以是 string 或 []MediaContent
}

type MediaContent struct {
    Type       string `json:"type"` // text/image_url/input_audio/file/video_url
    Text       string `json:"text,omitempty"`
    ImageUrl   any    `json:"image_url,omitempty"`
    InputAudio any    `json:"input_audio,omitempty"`
    VideoUrl   any    `json:"video_url,omitempty"`
}
```

**统一处理能力**：
- 支持纯文本、图文混排、音频、视频
- 自动解析和转换不同格式
- 支持 Base64 和 URL 两种方式

---

## 三、中继适配器模式（Relay Adapter）

### 3.1 适配器接口定义

#### **核心接口**（`relay/channel/adapter.go:13-30`）

```go
type Adaptor interface {
    Init(info *relaycommon.RelayInfo)

    // 请求转换
    ConvertOpenAIRequest(c *gin.Context, info *relaycommon.RelayInfo,
                         request *dto.GeneralOpenAIRequest) (any, error)
    ConvertImageRequest(c *gin.Context, info *relaycommon.RelayInfo,
                        request dto.ImageRequest) (any, error)

    // 请求执行
    GetRequestURL(info *relaycommon.RelayInfo) (string, error)
    SetupRequestHeader(c *gin.Context, req *http.Header, info *relaycommon.RelayInfo) error
    DoRequest(c *gin.Context, info *relaycommon.RelayInfo, requestBody io.Reader) (any, error)

    // 响应处理
    DoResponse(c *gin.Context, resp *http.Response, info *relaycommon.RelayInfo) (usage any, err *types.NewAPIError)
}
```

### 3.2 任务型适配器（TaskAdaptor）

对于异步任务（图片/视频生成），使用专门的任务适配器（`relay/channel/adapter.go:32-51`）：

```go
type TaskAdaptor interface {
    Init(info *relaycommon.RelayInfo)

    // 请求验证与构建
    ValidateRequestAndSetAction(c *gin.Context, info *relaycommon.RelayInfo) *dto.TaskError
    BuildRequestURL(info *relaycommon.RelayInfo) (string, error)
    BuildRequestHeader(c *gin.Context, req *http.Request, info *relaycommon.RelayInfo) error
    BuildRequestBody(c *gin.Context, info *relaycommon.RelayInfo) (io.Reader, error)

    // 任务执行与查询
    DoRequest(c *gin.Context, info *relaycommon.RelayInfo, requestBody io.Reader) (*http.Response, error)
    DoResponse(c *gin.Context, resp *http.Response, info *relaycommon.RelayInfo) (taskID string, taskData []byte, err *dto.TaskError)
    FetchTask(baseUrl, key string, body map[string]any) (*http.Response, error)
    ParseTaskResult(respBody []byte) (*relaycommon.TaskInfo, error)
}
```

### 3.3 适配器工厂模式

**获取适配器**（`relay/relay_adaptor.go:46-112`）：

```go
func GetAdaptor(apiType int) channel.Adaptor {
    switch apiType {
    case constant.APITypeOpenAI:
        return &openai.Adaptor{}
    case constant.APITypeAnthropic:
        return &claude.Adaptor{}
    case constant.APITypeGemini:
        return &gemini.Adaptor{}
    case constant.APITypeAli:
        return &ali.Adaptor{}
    // ... 30+ 平台适配器
    }
    return nil
}

func GetTaskAdaptor(platform constant.TaskPlatform) channel.TaskAdaptor {
    switch platform {
    case constant.TaskPlatformSuno:
        return &suno.TaskAdaptor{}
    // 视频平台
    case constant.ChannelTypeKling:
        return &kling.TaskAdaptor{}
    case constant.ChannelTypeSora:
        return &tasksora.TaskAdaptor{}
    // ...
    }
}
```

---

## 四、图片生成统一处理流程

### 4.1 图片生成完整流程

#### **流程图**：

```
用户请求 (OpenAI ImageRequest)
    ↓
[ImageHelper] (relay/image_handler.go:21)
    ↓
1. 解析请求 → dto.ImageRequest
    ↓
2. 选择适配器 → GetAdaptor(apiType)
    ↓
3. 转换请求 → adaptor.ConvertImageRequest()
    |
    ├→ OpenAI: 直接传递
    ├→ 阿里百炼: oaiImage2Ali()
    ├→ Jimeng: 转换为 Jimeng 特定格式
    └→ 其他平台...
    ↓
4. 发送请求 → adaptor.DoRequest()
    ↓
5. 处理响应 → adaptor.DoResponse()
    |
    ├→ 同步返回: 直接返回图片URL/Base64
    └→ 异步任务: 轮询等待任务完成
    ↓
6. 统一输出 → dto.ImageResponse
```

### 4.2 关键代码分析

#### **主处理函数**（`relay/image_handler.go:21-128`）

```go
func ImageHelper(c *gin.Context, info *relaycommon.RelayInfo) *types.NewAPIError {
    // 1. 获取并复制请求
    imageReq := info.Request.(*dto.ImageRequest)
    request, _ := common.DeepCopy(imageReq)

    // 2. 模型映射
    helper.ModelMappedHelper(c, info, request)

    // 3. 获取适配器
    adaptor := GetAdaptor(info.ApiType)
    adaptor.Init(info)

    // 4. 转换请求
    convertedRequest, _ := adaptor.ConvertImageRequest(c, info, *request)

    // 5. 序列化并应用参数覆盖
    jsonData, _ := common.Marshal(convertedRequest)
    if len(info.ParamOverride) > 0 {
        jsonData, _ = relaycommon.ApplyParamOverride(jsonData, info.ParamOverride)
    }

    // 6. 发送请求
    resp, _ := adaptor.DoRequest(c, info, bytes.NewBuffer(jsonData))

    // 7. 处理响应
    usage, _ := adaptor.DoResponse(c, httpResp, info)

    // 8. 计费
    postConsumeQuota(c, info, usage, logContent)
}
```

### 4.3 具体平台适配示例

#### **示例1: 阿里百炼图片生成**（`relay/channel/ali/image.go:23-58`）

```go
// OpenAI格式 → 阿里格式
func oaiImage2Ali(request dto.ImageRequest) (*AliImageRequest, error) {
    var imageRequest AliImageRequest
    imageRequest.Model = request.Model
    imageRequest.ResponseFormat = request.ResponseFormat

    // 处理扩展字段
    if request.Extra != nil {
        if val, ok := request.Extra["parameters"]; ok {
            json.Unmarshal(val, &imageRequest.Parameters)
        }
    }

    // 标准字段映射
    imageRequest.Parameters = AliImageParameters{
        Size:      strings.Replace(request.Size, "x", "*", -1), // 1024x1024 → 1024*1024
        N:         int(request.N),
        Watermark: request.Watermark,
    }

    imageRequest.Input = AliImageInput{
        Prompt: request.Prompt,
    }

    return &imageRequest, nil
}
```

**转换关键点**：
1. **尺寸格式转换**：`1024x1024` → `1024*1024`
2. **额外参数提取**：从 `Extra` 字段提取阿里特有参数
3. **异步任务处理**：调用 `asyncTaskWait()` 轮询任务状态

#### **示例2: Jimeng图片生成**（`relay/channel/jimeng/image.go:50-89`）

```go
func jimengImageHandler(c *gin.Context, resp *http.Response, info *relaycommon.RelayInfo) (*dto.Usage, *types.NewAPIError) {
    // 1. 读取响应
    var jimengResponse ImageResponse
    responseBody, _ := io.ReadAll(resp.Body)
    json.Unmarshal(responseBody, &jimengResponse)

    // 2. 检查错误
    if jimengResponse.Code != 10000 {
        return nil, types.WithOpenAIError(...)
    }

    // 3. 转换为OpenAI格式
    fullTextResponse := responseJimeng2OpenAIImage(c, &jimengResponse, info)

    // 4. 返回统一格式
    jsonResponse, _ := json.Marshal(fullTextResponse)
    c.Writer.Write(jsonResponse)

    return &dto.Usage{}, nil
}

// Jimeng响应 → OpenAI ImageResponse
func responseJimeng2OpenAIImage(response *ImageResponse, info *relaycommon.RelayInfo) *dto.ImageResponse {
    imageResponse := dto.ImageResponse{Created: info.StartTime.Unix()}

    // Base64格式图片
    for _, base64Data := range response.Data.BinaryDataBase64 {
        imageResponse.Data = append(imageResponse.Data, dto.ImageData{
            B64Json: base64Data,
        })
    }

    // URL格式图片
    for _, imageUrl := range response.Data.ImageUrls {
        imageResponse.Data = append(imageResponse.Data, dto.ImageData{
            Url: imageUrl,
        })
    }

    return &imageResponse
}
```

---

## 五、视频生成统一处理流程

### 5.1 视频任务处理架构

视频生成采用**异步任务模式**，完整流程：

```
用户提交任务 (VideoRequest)
    ↓
[RelayTaskSubmit] (relay/relay_task.go:27)
    ↓
1. 验证请求 → ValidateRequestAndSetAction()
    ↓
2. 预扣费用 → 计算quota并检查余额
    ↓
3. 构建请求 → BuildRequestBody()
    |
    ├→ Kling: 转换为Kling格式 + JWT签名
    ├→ Sora: 保持multipart格式
    └→ 其他平台...
    ↓
4. 提交任务 → DoRequest()
    ↓
5. 保存任务ID → 存入数据库
    ↓
6. 返回任务ID给用户
    ↓
    ↓
[用户查询任务状态]
    ↓
[RelayTaskFetch] → FetchTask()
    ↓
7. 查询上游状态 → ParseTaskResult()
    ↓
8. 更新本地状态 → 数据库
    ↓
9. 返回任务状态/结果URL
```

### 5.2 统一视频请求结构

**VideoRequest DTO**（`dto/video.go:3-16`）：

```go
type VideoRequest struct {
    Model          string         `json:"model,omitempty"`
    Prompt         string         `json:"prompt,omitempty"`         // 文本提示
    Image          string         `json:"image,omitempty"`          // 图生视频
    Duration       float64        `json:"duration"`                 // 时长(秒)
    Width          int            `json:"width"`                    // 宽度
    Height         int            `json:"height"`                   // 高度
    Fps            int            `json:"fps,omitempty"`            // 帧率
    Seed           int            `json:"seed,omitempty"`           // 随机种子
    N              int            `json:"n,omitempty"`              // 生成数量
    ResponseFormat string         `json:"response_format,omitempty"`
    Metadata       map[string]any `json:"metadata,omitempty"`       // 平台特定参数
}
```

**设计亮点**：
- `Metadata` 字段承载平台特有参数（如负面提示、风格控制等）
- 支持文生视频和图生视频两种模式
- 统一的时长/尺寸/帧率参数

### 5.3 平台适配器实现

#### **示例1: Kling视频生成**（`relay/channel/task/kling/adaptor.go:143-162`）

```go
// 构建Kling请求体
func (a *TaskAdaptor) BuildRequestBody(c *gin.Context, info *relaycommon.RelayInfo) (io.Reader, error) {
    req := c.Get("task_request").(relaycommon.TaskSubmitReq)

    // 转换为Kling格式
    body := &requestPayload{
        Prompt:      req.Prompt,
        Image:       req.Image,
        Mode:        defaultString(req.Mode, "std"),
        Duration:    fmt.Sprintf("%d", defaultInt(req.Duration, 5)),
        AspectRatio: a.getAspectRatio(req.Size),     // 转换尺寸格式
        ModelName:   req.Model,
        CfgScale:    0.5,
    }

    // 从Metadata提取扩展参数
    metadataBytes, _ := json.Marshal(req.Metadata)
    json.Unmarshal(metadataBytes, &body)  // 自动填充扩展字段

    // 判断任务类型
    if body.Image == "" {
        c.Set("action", constant.TaskActionTextGenerate)  // 文生视频
    } else {
        c.Set("action", constant.TaskActionGenerate)      // 图生视频
    }

    return bytes.NewReader(jsonData), nil
}

// 尺寸转换
func (a *TaskAdaptor) getAspectRatio(size string) string {
    switch size {
    case "1024x1024": return "1:1"
    case "1280x720":  return "16:9"
    case "720x1280":  return "9:16"
    default:          return "1:1"
    }
}
```

**Kling特殊处理**：
1. **JWT认证**：使用 `access_key|secret_key` 生成JWT token
2. **动态路径选择**：文生视频和图生视频使用不同API路径
3. **宽高比转换**：将像素尺寸转换为比例格式

#### **示例2: Sora视频生成**（`relay/channel/task/sora/adaptor.go:88-94`）

```go
func (a *TaskAdaptor) BuildRequestBody(c *gin.Context, info *relaycommon.RelayInfo) (io.Reader, error) {
    // Sora使用multipart/form-data格式，直接透传原始请求体
    cachedBody, err := common.GetRequestBody(c)
    return bytes.NewReader(cachedBody), nil
}
```

**Sora特点**：
- 完全兼容OpenAI官方API格式
- 支持multipart上传（图片+参数）
- 直接透传请求体，无需特殊转换

### 5.4 任务状态查询与转换

#### **任务状态映射**（各平台适配器 `ParseTaskResult` 方法）

| 平台 | 平台状态 | 统一状态 |
|------|----------|----------|
| Kling | submitted | TaskStatusSubmitted |
| Kling | processing | TaskStatusInProgress |
| Kling | succeed | TaskStatusSuccess |
| Kling | failed | TaskStatusFailure |
| Sora | queued/pending | TaskStatusQueued |
| Sora | processing/in_progress | TaskStatusInProgress |
| Sora | completed | TaskStatusSuccess |
| Sora | failed/cancelled | TaskStatusFailure |

**Kling状态解析**（`relay/channel/task/kling/adaptor.go:338-367`）：

```go
func (a *TaskAdaptor) ParseTaskResult(respBody []byte) (*relaycommon.TaskInfo, error) {
    var resPayload responsePayload
    json.Unmarshal(respBody, &resPayload)

    taskInfo := &relaycommon.TaskInfo{
        Code:   resPayload.Code,
        TaskID: resPayload.Data.TaskId,
        Reason: resPayload.Message,
    }

    // 状态映射
    switch resPayload.Data.TaskStatus {
    case "submitted":
        taskInfo.Status = model.TaskStatusSubmitted
    case "processing":
        taskInfo.Status = model.TaskStatusInProgress
    case "succeed":
        taskInfo.Status = model.TaskStatusSuccess
        // 提取视频URL
        if len(resPayload.Data.TaskResult.Videos) > 0 {
            taskInfo.Url = resPayload.Data.TaskResult.Videos[0].Url
        }
    case "failed":
        taskInfo.Status = model.TaskStatusFailure
    }

    return taskInfo, nil
}
```

---

## 六、参数转换的关键技术

### 6.1 发送前的处理机制

在请求发送给各平台前，系统执行以下转换：

#### **1. 模型名称映射**（`relay/helper/model_mapped.go`）

```go
func ModelMappedHelper(c *gin.Context, info *relaycommon.RelayInfo, request any) error {
    // 查询渠道的模型映射配置
    modelMapping := info.ChannelSetting.ModelMapping

    // 如果有映射配置，替换模型名
    if mappedModel, ok := modelMapping[request.Model]; ok {
        request.SetModelName(mappedModel)
        info.UpstreamModelName = mappedModel
    }
}
```

**作用**：
- 用户请求 `gpt-4` → 实际调用 `gpt-4-turbo`
- 屏蔽平台差异，统一模型名称

#### **2. 参数覆盖**（`relay/common/override.go`）

```go
func ApplyParamOverride(jsonData []byte, overrideMap map[string]any) ([]byte, error) {
    var bodyMap map[string]interface{}
    json.Unmarshal(jsonData, &bodyMap)

    // 递归覆盖参数
    for key, value := range overrideMap {
        bodyMap[key] = value
    }

    return json.Marshal(bodyMap)
}
```

**应用场景**：
- 强制设置 `temperature=0.7`
- 注入特定的 `system` 消息
- 限制 `max_tokens` 上限

#### **3. 格式转换**（各适配器的 `Convert*Request` 方法）

以OpenAI请求转Claude为例（`service/convert.go`）：

```go
func RequestOpenAI2Claude(request *dto.GeneralOpenAIRequest) *dto.ClaudeRequest {
    claudeReq := &dto.ClaudeRequest{
        Model:       request.Model,
        MaxTokens:   request.MaxTokens,
        Temperature: request.Temperature,
        TopP:        request.TopP,
        Stream:      request.Stream,
    }

    // 转换消息格式
    for _, msg := range request.Messages {
        if msg.Role == "system" {
            claudeReq.System = msg.StringContent()  // System消息单独提取
        } else {
            // 转换Content格式
            content := convertMessageContent(msg)
            claudeReq.Messages = append(claudeReq.Messages, dto.ClaudeMessage{
                Role:    msg.Role,
                Content: content,
            })
        }
    }

    return claudeReq
}

func convertMessageContent(msg dto.Message) []dto.ClaudeContent {
    var contents []dto.ClaudeContent

    for _, mc := range msg.ParseContent() {
        switch mc.Type {
        case "text":
            contents = append(contents, dto.ClaudeContent{
                Type: "text",
                Text: mc.Text,
            })
        case "image_url":
            imageUrl := mc.GetImageMedia()
            // Base64格式
            if strings.HasPrefix(imageUrl.Url, "data:") {
                contents = append(contents, dto.ClaudeContent{
                    Type: "image",
                    Source: dto.ClaudeImageSource{
                        Type:      "base64",
                        MediaType: extractMimeType(imageUrl.Url),
                        Data:      extractBase64Data(imageUrl.Url),
                    },
                })
            } else {
                // URL格式需要下载转Base64
                contents = append(contents, ...)
            }
        }
    }

    return contents
}
```

**转换关键点**：
1. **System消息处理**：OpenAI的system角色转为Claude的system字段
2. **图片格式转换**：URL图片 → 下载 → Base64
3. **Content结构重组**：`[]MediaContent` → `[]ClaudeContent`

### 6.2 响应转换回OpenAI格式

所有平台响应最终转为统一的OpenAI格式返回给用户：

#### **Claude → OpenAI**（`service/convert.go`）

```go
func ResponseClaude2OpenAI(claudeResp *dto.ClaudeResponse) *dto.OpenAITextResponse {
    oaiResp := &dto.OpenAITextResponse{
        ID:      claudeResp.ID,
        Object:  "chat.completion",
        Created: time.Now().Unix(),
        Model:   claudeResp.Model,
    }

    // 转换Choice
    for _, content := range claudeResp.Content {
        oaiResp.Choices = append(oaiResp.Choices, dto.OpenAITextResponseChoice{
            Index: 0,
            Message: dto.Message{
                Role:    "assistant",
                Content: content.Text,
            },
            FinishReason: claudeResp.StopReason,
        })
    }

    // 转换Usage
    oaiResp.Usage = dto.Usage{
        PromptTokens:     claudeResp.Usage.InputTokens,
        CompletionTokens: claudeResp.Usage.OutputTokens,
        TotalTokens:      claudeResp.Usage.InputTokens + claudeResp.Usage.OutputTokens,
    }

    return oaiResp
}
```

#### **阿里图片 → OpenAI**（`relay/channel/ali/image.go:228-256`）

```go
func responseAli2OpenAIImage(response *AliResponse) *dto.ImageResponse {
    imageResponse := dto.ImageResponse{
        Created: time.Now().Unix(),
    }

    for _, data := range response.Output.Results {
        imageResponse.Data = append(imageResponse.Data, dto.ImageData{
            Url:     data.Url,
            B64Json: data.B64Image,
        })
    }

    return &imageResponse
}
```

---

## 七、核心设计模式总结

### 7.1 适配器模式应用

```
统一接口 Adaptor
    ↓
具体适配器实现
├── OpenAIAdaptor    (直接透传)
├── ClaudeAdaptor    (格式转换)
├── GeminiAdaptor    (格式转换)
├── AliAdaptor       (格式转换 + 异步任务)
├── JimengAdaptor    (格式转换)
└── ...30+ 平台
```

**优势**：
1. 新增平台只需实现适配器接口
2. 各平台逻辑完全隔离
3. 易于测试和维护

### 7.2 策略模式应用

不同请求类型使用不同处理策略：

```go
// relay/relay_adaptor.go
switch relayMode {
case constant.RelayModeChatCompletions:
    return TextHelper(c, info)
case constant.RelayModeImagesGenerations:
    return ImageHelper(c, info)
case constant.RelayModeVideoSubmit:
    return RelayTaskSubmit(c, info)
case constant.RelayModeVideoFetch:
    return RelayTaskFetch(c, relayMode)
}
```

### 7.3 工厂模式应用

```go
// 适配器工厂
func GetAdaptor(apiType int) channel.Adaptor
func GetTaskAdaptor(platform constant.TaskPlatform) channel.TaskAdaptor

// DTO工厂
func ParseRequest(c *gin.Context, relayMode int) (any, error)
```

---

## 八、关键技术细节

### 8.1 流式响应处理

对于支持流式输出的请求，系统实现了统一的流式转换：

```go
// relay/channel/openai/relay-openai.go:112
func OaiStreamHandler(c *gin.Context, info *relaycommon.RelayInfo, resp *http.Response) (*dto.Usage, *types.NewAPIError) {
    helper.StreamScannerHandler(c, resp, info, func(data string) bool {
        // 1. 解析每个SSE数据块
        var streamResponse dto.ChatCompletionsStreamResponse
        json.Unmarshal(data, &streamResponse)

        // 2. 格式转换（如需要）
        if info.ChannelSetting.ForceFormat {
            // 强制转换为标准OpenAI格式
        }

        // 3. 发送给客户端
        helper.StreamData(c, data)

        return true
    })
}
```

### 8.2 Token计费统计

系统实现了多维度的Token统计：

```go
// service/token_counter.go
func CountTokenInput(text string, model string) int {
    // 1. 根据模型选择tokenizer
    encoder := GetTokenEncoder(model)

    // 2. 统计文本token
    textTokens := encoder.Encode(text)

    // 3. 统计图片token
    imageTokens := CountImageTokens(images, detail)

    // 4. 统计音频token
    audioTokens := CountAudioTokens(audioData, format)

    return textTokens + imageTokens + audioTokens
}
```

**计费规则**：
- 文本：使用tiktoken编码器
- 图片：根据分辨率和detail级别计算
- 音频：按时长计算（1分钟 = 1000 tokens）
- 视频：固定价格模式

### 8.3 错误处理与重试

```go
// middleware/distributor.go
func ErrorHandler(c *gin.Context) {
    // 1. 捕获错误
    err := c.Errors.Last()

    // 2. 判断是否可重试
    if !err.ShouldRetry() {
        return
    }

    // 3. 选择下一个可用渠道
    nextChannel := selectNextChannel(c)

    // 4. 重试请求
    retryRequest(c, nextChannel)
}
```

---

## 九、扩展性设计

### 9.1 新增平台接入步骤

1. **定义常量**：在 `constant/api_type.go` 添加平台类型
2. **实现适配器**：
   ```go
   // relay/channel/newplatform/adaptor.go
   type Adaptor struct {}

   func (a *Adaptor) Init(info *relaycommon.RelayInfo) {}
   func (a *Adaptor) ConvertOpenAIRequest(...) (any, error) {
       // 实现格式转换
   }
   func (a *Adaptor) DoRequest(...) (any, error) {}
   func (a *Adaptor) DoResponse(...) (*dto.Usage, *types.NewAPIError) {
       // 实现响应转换
   }
   ```
3. **注册适配器**：在 `GetAdaptor()` 中添加case分支
4. **配置模型价格**：在 `model/pricing_default.go` 添加定价

### 9.2 新增请求格式支持

1. **定义DTO**：在 `dto/` 目录创建新格式结构体
2. **实现转换函数**：
   ```go
   func RequestOpenAI2NewFormat(req *dto.GeneralOpenAIRequest) *dto.NewFormatRequest
   func ResponseNewFormat2OpenAI(resp *dto.NewFormatResponse) *dto.OpenAITextResponse
   ```
3. **添加RelayFormat**：在 `types/relay_format.go` 定义新格式常量

---

## 十、总结

### 核心设计理念

1. **统一入口，多样出口**：
   - 用户统一使用OpenAI格式请求
   - 系统自动转换到30+不同平台
   - 响应统一转回OpenAI格式

2. **分层解耦**：
   - DTO层：定义统一数据结构
   - Adapter层：实现平台适配
   - Relay层：协调转换流程
   - Service层：提供公共服务

3. **可扩展架构**：
   - 插件化适配器设计
   - 工厂模式动态选择
   - 策略模式处理不同场景

### 关键技术亮点

| 功能 | 实现方式 | 位置 |
|------|----------|------|
| **统一参数** | DTO + json.RawMessage扩展字段 | `dto/*.go` |
| **格式转换** | 适配器模式 + 双向转换函数 | `relay/channel/*/adaptor.go` |
| **图片生成** | 同步/异步双模式处理 | `relay/image_handler.go` |
| **视频生成** | 异步任务 + 状态轮询 | `relay/relay_task.go` |
| **多格式输出** | RelayFormat + 响应转换 | `service/convert.go` |
| **流式响应** | SSE流解析 + 实时转换 | `relay/helper/stream_scanner.go` |
| **错误重试** | 渠道切换 + 失败重试 | `middleware/distributor.go` |
| **计费统计** | 多维Token计数 | `service/token_counter.go` |

### 项目优势

1. **高度统一**：用户无需学习各平台API差异
2. **易于扩展**：新增平台只需实现适配器接口
3. **灵活配置**：支持模型映射、参数覆盖、格式转换
4. **成本优化**：统一计费、缓存计费、配额管理
5. **生产就绪**：完善的错误处理、重试机制、监控日志

---

## 附录：主要文件索引

| 功能模块 | 核心文件 | 说明 |
|----------|----------|------|
| **统一请求** | `dto/openai_request.go` | 文本对话DTO |
|  | `dto/openai_image.go` | 图片生成DTO |
|  | `dto/video.go` | 视频生成DTO |
| **适配器接口** | `relay/channel/adapter.go` | 适配器接口定义 |
|  | `relay/relay_adaptor.go` | 适配器工厂 |
| **图片处理** | `relay/image_handler.go` | 图片生成主流程 |
|  | `relay/channel/ali/image.go` | 阿里图片适配 |
|  | `relay/channel/jimeng/image.go` | Jimeng适配 |
| **视频处理** | `relay/relay_task.go` | 视频任务主流程 |
|  | `relay/channel/task/kling/adaptor.go` | Kling适配 |
|  | `relay/channel/task/sora/adaptor.go` | Sora适配 |
| **格式转换** | `service/convert.go` | 格式转换函数 |
| **流式处理** | `relay/helper/stream_scanner.go` | 流式响应处理 |
| **Token计算** | `service/token_counter.go` | Token统计 |

---

**生成时间**: 2025-10-09
**项目版本**: New API (基于 One API 二次开发)
**分析范围**: 核心架构 + 图片/视频生成流程
