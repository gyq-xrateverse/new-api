# New API 项目请求调用路径分析

本文档详细描述了 New API 项目中请求从进入到处理完成的完整调用路径。

## 项目概述

New API 是一个 AI API 网关项目,基于 Gin 框架开发,主要功能是:
- 统一多个 AI 服务提供商的 API 接口
- 提供认证、限流、配额管理等功能
- 支持多种 AI 模型的请求转发和适配

---

## 一、系统启动流程

### 1. 入口点: `main.go:38`

```
main()
├── InitResources()                           # 初始化资源
│   ├── godotenv.Load(".env")                # 加载环境变量
│   ├── common.InitEnv()                     # 初始化环境配置
│   ├── logger.SetupLogger()                 # 初始化日志
│   ├── ratio_setting.InitRatioSettings()    # 初始化价格比率配置
│   ├── service.InitHttpClient()             # 初始化 HTTP 客户端
│   ├── service.InitTokenEncoders()          # 初始化 Token 编码器
│   ├── model.InitDB()                       # 初始化主数据库
│   ├── model.InitLogDB()                    # 初始化日志数据库
│   └── common.InitRedisClient()             # 初始化 Redis
│
├── gin.New()                                 # 创建 Gin 引擎
├── middleware 设置                           # 配置中间件
│   ├── gin.CustomRecovery()                 # panic 恢复
│   ├── middleware.RequestId()               # 请求 ID 中间件
│   ├── middleware.SetUpLogger()             # 日志中间件
│   └── sessions.Sessions()                  # Session 中间件
│
└── router.SetRouter()                        # 配置路由
    ├── SetApiRouter()                       # API 管理路由
    ├── SetDashboardRouter()                 # 仪表盘路由
    ├── SetRelayRouter()                     # 中继转发路由 ⭐
    ├── SetVideoRouter()                     # 视频相关路由
    └── SetWebRouter()                       # Web 前端路由
```

---

## 二、请求路由配置

### 1. 路由入口: `router/main.go:14`

主要路由设置在 `SetRouter()` 函数中,其中最核心的是 `SetRelayRouter()`。

### 2. 中继路由配置: `router/relay-router.go:13`

```
SetRelayRouter()
├── middleware.CORS()                         # 跨域中间件
├── middleware.DecompressRequestMiddleware()  # 解压请求中间件
├── middleware.StatsMiddleware()              # 统计中间件
│
├── /v1/models 路由组
│   ├── middleware.TokenAuth()               # Token 认证
│   ├── GET ""                               # 列出模型
│   └── GET "/:model"                        # 获取模型详情
│
├── /v1 路由组 ⭐ (核心 API 路由)
│   ├── middleware.TokenAuth()               # Token 认证
│   ├── middleware.ModelRequestRateLimit()   # 模型请求限流
│   └── middleware.Distribute()              # 分发中间件(选择渠道)
│       │
│       ├── WebSocket 路由
│       │   └── GET /realtime → controller.Relay(RelayFormatOpenAIRealtime)
│       │
│       └── HTTP 路由
│           ├── POST /messages               → controller.Relay(RelayFormatClaude)
│           ├── POST /chat/completions       → controller.Relay(RelayFormatOpenAI)
│           ├── POST /completions            → controller.Relay(RelayFormatOpenAI)
│           ├── POST /responses              → controller.Relay(RelayFormatOpenAIResponses)
│           ├── POST /images/generations     → controller.Relay(RelayFormatOpenAIImage)
│           ├── POST /embeddings             → controller.Relay(RelayFormatEmbedding)
│           ├── POST /audio/transcriptions   → controller.Relay(RelayFormatOpenAIAudio)
│           ├── POST /audio/speech           → controller.Relay(RelayFormatOpenAIAudio)
│           ├── POST /rerank                 → controller.Relay(RelayFormatRerank)
│           └── POST /models/*path           → controller.Relay(RelayFormatGemini)
│
├── /mj 路由组 (Midjourney)
│   └── 各种 Midjourney 相关路由
│
├── /suno 路由组 (Suno)
│   └── 任务提交和查询路由
│
└── /v1beta 路由组 (Gemini)
    └── Gemini API 路由
```

---

## 三、中间件处理链

请求在到达控制器之前,会经过一系列中间件处理。以 `/v1/chat/completions` 为例:

### 中间件执行顺序:

```
请求进入
  ↓
① middleware.CORS()                           # router/relay-router.go:14
  处理跨域请求
  ↓
② middleware.DecompressRequestMiddleware()    # router/relay-router.go:15
  解压请求体(如果是压缩的)
  ↓
③ middleware.StatsMiddleware()                # router/relay-router.go:16
  记录请求统计信息
  ↓
④ middleware.TokenAuth()                      # router/relay-router.go:64
  ├── 从 Header 中提取 Token                  # middleware/auth.go:178
  ├── 验证 Token 有效性                       # middleware/auth.go:230
  ├── 检查 IP 限制                            # middleware/auth.go:242
  ├── 获取用户信息                            # middleware/auth.go:251
  ├── 设置用户分组                            # middleware/auth.go:264-280
  └── 设置 Context 信息                       # middleware/auth.go:291-318
      (id, token_id, token_name, token_quota, etc.)
  ↓
⑤ middleware.ModelRequestRateLimit()          # router/relay-router.go:65
  检查模型级别的请求频率限制
  ↓
⑥ middleware.Distribute()                     # router/relay-router.go:69 或 77
  ├── 解析请求获取模型名                      # middleware/distributor.go:32
  │   └── getModelRequest()                  # middleware/distributor.go:125
  │       ├── 根据路径判断请求类型
  │       ├── 解析 JSON body 获取 model
  │       └── 处理特殊路径(audio, image, etc.)
  │
  ├── 检查 Token 模型权限                     # middleware/distributor.go:55-72
  │
  ├── 选择合适的渠道                          # middleware/distributor.go:98
  │   └── model.CacheGetRandomSatisfiedChannel()
  │       ├── 根据用户分组、模型名查找可用渠道
  │       ├── 从缓存或数据库获取渠道列表
  │       └── 随机选择一个可用渠道
  │
  └── 设置渠道上下文信息                      # middleware/distributor.go:120
      └── SetupContextForSelectedChannel()   # middleware/distributor.go:257
          ├── 设置渠道 ID、名称、类型
          ├── 设置渠道配置、密钥
          ├── 设置基础 URL
          └── 获取下一个可用的 API Key
  ↓
进入控制器 controller.Relay()
```

---

## 四、控制器层处理

### 1. 核心控制器: `controller/relay.go:63`

```
controller.Relay(c, relayFormat)
  ├── 获取请求上下文信息                      # relay.go:65-67
  │   ├── requestId
  │   ├── group (用户分组)
  │   └── originalModel (原始模型名)
  │
  ├── WebSocket 处理 (如果是 Realtime)       # relay.go:74-82
  │   └── upgrader.Upgrade()
  │
  ├── 获取并验证请求                          # relay.go:103
  │   └── helper.GetAndValidateRequest()
  │       ├── 根据 relayFormat 解析请求体
  │       ├── 验证必填字段
  │       └── 返回统一的请求对象
  │
  ├── 生成中继信息                            # relay.go:109
  │   └── relaycommon.GenRelayInfo()
  │       ├── 从 Context 提取所有相关信息
  │       ├── 创建 RelayInfo 结构
  │       └── 设置中继模式、流式标志等
  │
  ├── 敏感词检测                              # relay.go:117-123
  │   └── service.CheckSensitiveText()
  │
  ├── 计算 Token 数量                         # relay.go:126
  │   └── service.CountRequestToken()
  │
  ├── 计算价格                                # relay.go:134
  │   └── helper.ModelPriceHelper()
  │
  ├── 预扣费                                  # relay.go:142
  │   └── service.PreConsumeQuota()
  │
  ├── 重试循环 (最多重试 RetryTimes 次)      # relay.go:154
  │   ├── 获取渠道信息                        # relay.go:155
  │   │   └── getChannel()
  │   │
  │   ├── 根据 relayFormat 调用处理器         # relay.go:166-175
  │   │   ├── RelayFormatOpenAIRealtime → relay.WssHelper()
  │   │   ├── RelayFormatClaude → relay.ClaudeHelper()
  │   │   ├── RelayFormatGemini → geminiRelayHandler()
  │   │   └── default → relayHandler()
  │   │
  │   ├── 处理渠道错误                        # relay.go:181
  │   │   └── processChannelError()
  │   │       ├── 记录错误日志
  │   │       ├── 判断是否需要禁用渠道
  │   │       └── 保存错误日志到数据库
  │   │
  │   └── 判断是否需要重试                    # relay.go:183
  │       └── shouldRetry()
  │
  └── 返回预扣费(如果失败)                    # relay.go:147-152
```

### 2. 请求处理器分发: `controller/relay.go:30`

```
relayHandler(c, info)
  根据 info.RelayMode 选择不同的处理器:

  ├── RelayModeImagesGenerations/Edits
  │   └── relay.ImageHelper()              # relay/image_handler.go
  │
  ├── RelayModeAudio*
  │   └── relay.AudioHelper()              # relay/audio_handler.go
  │
  ├── RelayModeRerank
  │   └── relay.RerankHelper()             # relay/rerank_handler.go
  │
  ├── RelayModeEmbeddings
  │   └── relay.EmbeddingHelper()          # relay/embedding_handler.go
  │
  ├── RelayModeResponses
  │   └── relay.ResponsesHelper()          # relay/responses_handler.go
  │
  └── default (文本生成)
      └── relay.TextHelper()               # relay/compatible_handler.go
```

---

## 五、Relay 层处理 (适配器模式)

### 1. 获取适配器: `relay/relay_adaptor.go:46`

```
GetAdaptor(apiType)
  根据渠道类型返回对应的适配器:

  ├── APITypeOpenAI    → openai.Adaptor
  ├── APITypeAnthropic → claude.Adaptor
  ├── APITypeGemini    → gemini.Adaptor
  ├── APITypeAzure     → openai.Adaptor
  ├── APITypeAli       → ali.Adaptor
  ├── APITypeBaidu     → baidu.Adaptor
  ├── APITypeZhipu     → zhipu.Adaptor
  └── ... (30+ 种渠道类型)
```

### 2. 适配器接口: `relay/channel/adapter.go:13`

所有适配器都实现以下接口:

```go
type Adaptor interface {
    Init(info *relaycommon.RelayInfo)

    // 获取请求 URL
    GetRequestURL(info *relaycommon.RelayInfo) (string, error)

    // 设置请求头
    SetupRequestHeader(c *gin.Context, req *http.Header, info *relaycommon.RelayInfo) error

    // 转换请求格式
    ConvertOpenAIRequest(c *gin.Context, info *relaycommon.RelayInfo, request *dto.GeneralOpenAIRequest) (any, error)
    ConvertClaudeRequest(...)
    ConvertGeminiRequest(...)
    ConvertEmbeddingRequest(...)
    ConvertImageRequest(...)
    ConvertAudioRequest(...)

    // 执行请求
    DoRequest(c *gin.Context, info *relaycommon.RelayInfo, requestBody io.Reader) (any, error)

    // 处理响应
    DoResponse(c *gin.Context, resp *http.Response, info *relaycommon.RelayInfo) (usage any, err *types.NewAPIError)

    GetModelList() []string
    GetChannelName() string
}
```

### 3. OpenAI 适配器处理流程 (示例): `relay/channel/openai/adaptor.go`

```
openai.Adaptor 处理流程:

① Init()                                      # adaptor.go:93
   └── 初始化适配器配置

② GetRequestURL()                            # adaptor.go:106
   ├── 根据渠道类型构建 URL
   │   ├── Azure: 特殊的 deployment URL
   │   ├── MiniMax: 调用 minimax.GetRequestURL()
   │   ├── Custom: 使用自定义 URL 模板
   │   └── 其他: 标准 OpenAI URL 格式
   └── 返回完整的请求 URL

③ SetupRequestHeader()                       # adaptor.go:177
   ├── 设置通用 API 请求头
   ├── Azure: 设置 api-key
   ├── OpenAI: 设置 Authorization Bearer
   └── 特殊处理(OpenRouter, Realtime 等)

④ ConvertOpenAIRequest()                     # adaptor.go:212
   ├── 处理 StreamOptions
   ├── 处理 OpenRouter 特殊逻辑
   ├── 处理 o 系列模型
   │   ├── MaxCompletionTokens 转换
   │   ├── Temperature 设置
   │   ├── ReasoningEffort 解析
   │   └── system → developer 角色转换
   └── 返回转换后的请求

⑤ DoRequest()                                # adaptor.go:553
   ├── 根据 RelayMode 选择请求方式:
   │   ├── Audio/Image: channel.DoFormRequest()
   │   ├── Realtime: channel.DoWssRequest()
   │   └── 其他: channel.DoApiRequest()
   │       └── channel/api_request.go
   │           ├── 创建 HTTP 请求
   │           ├── 设置请求头
   │           ├── 设置请求体
   │           └── 发送请求
   └── 返回 HTTP Response

⑥ DoResponse()                               # adaptor.go:565
   根据 RelayMode 选择响应处理器:
   ├── Realtime → OpenaiRealtimeHandler()
   ├── AudioSpeech → OpenaiTTSHandler()
   ├── Audio → OpenaiSTTHandler()
   ├── Images → OpenaiHandlerWithUsage()
   ├── Rerank → RerankHandler()
   ├── Responses →
   │   ├── Stream: OaiResponsesStreamHandler()
   │   └── Non-stream: OaiResponsesHandler()
   └── 默认文本生成 →
       ├── Stream: OaiStreamHandler()         # relay/channel/openai/relay-openai.go
       │   ├── 设置响应头
       │   ├── 流式读取响应
       │   ├── 解析 SSE 数据
       │   ├── 转发给客户端
       │   ├── 记录使用量
       │   └── 后扣费
       └── Non-stream: OpenaiHandler()
           ├── 读取完整响应
           ├── 解析 JSON
           ├── 转发给客户端
           ├── 记录使用量
           └── 后扣费
```

---

## 六、渠道处理和第三方调用

### 1. API 请求执行: `relay/channel/api_request.go`

```
channel.DoApiRequest(adaptor, c, info, requestBody)
  ├── 构建请求 URL
  │   └── adaptor.GetRequestURL(info)
  │
  ├── 转换请求格式
  │   ├── adaptor.ConvertOpenAIRequest()   # 如果是 OpenAI 格式
  │   ├── adaptor.ConvertClaudeRequest()   # 如果是 Claude 格式
  │   ├── adaptor.ConvertGeminiRequest()   # 如果是 Gemini 格式
  │   └── ... (根据请求类型选择)
  │
  ├── 序列化请求体
  │   └── json.Marshal(convertedRequest)
  │
  ├── 创建 HTTP 请求
  │   └── http.NewRequestWithContext()
  │
  ├── 设置请求头
  │   └── adaptor.SetupRequestHeader()
  │       ├── 设置 Content-Type
  │       ├── 设置 Authorization
  │       ├── 设置特定渠道的 header
  │       └── 应用渠道的 header override
  │
  ├── 发送请求到上游 API
  │   └── httpClient.Do(request)            # service/http_client.go
  │       └── 使用配置好的 HTTP 客户端
  │           ├── 超时设置
  │           ├── 代理设置
  │           └── TLS 配置
  │
  └── 返回 HTTP Response
```

### 2. 不同渠道的特殊处理

#### OpenAI 渠道
```
relay/channel/openai/
  ├── adaptor.go         # 适配器主逻辑
  ├── relay-openai.go    # 响应处理
  ├── helper.go          # 辅助函数
  └── constant.go        # 常量定义
```

#### Claude 渠道
```
relay/channel/claude/
  ├── adaptor.go         # Claude 适配器
  ├── relay-claude.go    # Claude 响应处理
  ├── dto.go             # Claude 数据结构
  └── constant.go        # Claude 常量
```

#### 其他渠道类似结构
- `ali/` - 阿里云
- `baidu/` - 百度
- `gemini/` - Google Gemini
- `zhipu/` - 智谱
- `aws/` - AWS Bedrock
- ... 等 30+ 渠道

---

## 七、任务处理流程 (Suno/视频等)

对于长时间运行的任务(如 Suno 音乐生成、视频生成):

```
RelayTask(c) → controller/relay.go:383

  ├── 生成 RelayInfo
  │   └── relaycommon.GenRelayInfo(c, RelayFormatTask, nil, nil)
  │
  ├── 任务处理
  │   └── taskRelayHandler(c, relayInfo)
  │       └── relay.RelayTaskSubmit(c, relayInfo)  # relay/relay_task.go:27
  │
  ├── 获取任务适配器
  │   └── GetTaskAdaptor(platform)               # relay/relay_adaptor.go:122
  │       ├── TaskPlatformSuno → suno.TaskAdaptor
  │       ├── ChannelTypeKling → kling.TaskAdaptor
  │       ├── ChannelTypeVertexAi → vertex.TaskAdaptor
  │       └── ... 其他任务平台
  │
  ├── 验证请求
  │   └── adaptor.ValidateRequestAndSetAction()
  │
  ├── 计算价格和预扣费
  │   ├── 获取模型价格
  │   ├── 计算配额
  │   └── 检查用户余额
  │
  ├── 构建请求
  │   ├── adaptor.BuildRequestURL()
  │   ├── adaptor.BuildRequestHeader()
  │   └── adaptor.BuildRequestBody()
  │
  ├── 发送请求
  │   └── adaptor.DoRequest()
  │
  ├── 处理响应
  │   └── adaptor.DoResponse()
  │       └── 返回 taskID 和 taskData
  │
  ├── 保存任务到数据库
  │   └── task.Insert()
  │
  └── 后扣费
      └── service.PostConsumeQuota()
```

---

## 八、完整请求调用链示例

以 `POST /v1/chat/completions` 为例:

```
【客户端】POST /v1/chat/completions
  ↓
【Gin 引擎】接收请求
  ↓
【中间件链】
  ① CORS 处理
  ② 解压请求
  ③ 统计记录
  ④ Token 认证
     - 验证 sk-xxx Token
     - 加载用户信息
     - 检查用户状态、配额
  ⑤ 模型请求限流
  ⑥ 渠道分发
     - 解析请求获取模型名: gpt-4
     - 检查 Token 模型权限
     - 根据用户分组和模型选择渠道
     - 设置渠道上下文(渠道 ID、密钥、基础 URL)
  ↓
【控制器】controller.Relay(c, RelayFormatOpenAI)
  ① 获取并验证请求
     - 解析 JSON body
     - 验证必填字段
  ② 生成 RelayInfo
     - 整合所有上下文信息
  ③ 敏感词检测
  ④ Token 计数
     - 使用 tiktoken 计算输入 token 数
  ⑤ 价格计算
     - 模型价格 × 分组倍率 × token 数
  ⑥ 预扣费
     - 从用户配额扣除预估费用
  ⑦ 调用处理器
     └── relayHandler() → relay.TextHelper()
  ↓
【Relay 层】relay/compatible_handler.go
  ① 获取适配器
     └── GetAdaptor(ChannelTypeOpenAI) → openai.Adaptor
  ② 初始化适配器
     └── adaptor.Init(info)
  ③ 转换请求
     └── adaptor.ConvertOpenAIRequest()
        - 处理 stream_options
        - 处理 o 系列模型特殊逻辑
  ④ 执行请求
     └── adaptor.DoRequest()
        └── channel.DoApiRequest()
           ├── 获取请求 URL: https://api.openai.com/v1/chat/completions
           ├── 设置请求头: Authorization: Bearer sk-...
           ├── 发送 HTTP POST 请求
           └── 返回 Response
  ⑤ 处理响应
     └── adaptor.DoResponse()
        ├── 如果是流式: OaiStreamHandler()
        │   ├── 设置 SSE 响应头
        │   ├── 逐行读取 SSE 数据
        │   ├── 解析 data: {...}
        │   ├── 转发给客户端
        │   ├── 累计 usage
        │   └── 返回总 usage
        └── 如果是非流式: OpenaiHandler()
            ├── 读取完整响应
            ├── 解析 JSON
            ├── 转发给客户端
            └── 返回 usage
  ⑥ 后扣费
     - 根据实际 usage 计算费用
     - 退还预扣费
     - 扣除实际费用
  ⑦ 记录日志
     - 保存到 logs 表
     - 记录 token 使用量、费用等
  ↓
【客户端】收到响应
```

---

## 九、关键数据结构

### 1. RelayInfo: `relay/common/relay_info.go`

```go
type RelayInfo struct {
    // 基础信息
    RelayMode        int
    RelayFormat      types.RelayFormat
    IsStream         bool

    // 用户信息
    UserId           int
    UserGroup        string
    UsingGroup       string
    TokenId          int
    TokenName        string

    // 渠道信息
    ChannelId        int
    ChannelType      int
    ChannelName      string
    ChannelBaseUrl   string
    ApiKey           string
    ApiVersion       string
    Organization     string

    // 模型信息
    OriginModelName  string
    UpstreamModelName string

    // 请求信息
    RequestURLPath   string
    PromptTokens     int

    // 配置信息
    ChannelSetting   dto.ChannelSettings
    ChannelOtherSettings dto.ChannelOtherSettings

    // 其他
    ...
}
```

### 2. GeneralOpenAIRequest: `dto/openai_request.go`

```go
type GeneralOpenAIRequest struct {
    Model            string
    Messages         []Message
    Stream           bool
    Temperature      *float64
    TopP             *float64
    MaxTokens        int
    MaxCompletionTokens int
    FrequencyPenalty *float64
    PresencePenalty  *float64
    N                int
    StreamOptions    *StreamOptions
    Tools            []Tool
    ...
}
```

---

## 十、错误处理和重试机制

### 1. 错误处理流程

```
发生错误
  ↓
processChannelError(channelError, err)        # controller/relay.go:278
  ├── 记录错误日志
  │   └── logger.LogError()
  │
  ├── 判断是否需要禁用渠道
  │   └── service.ShouldDisableChannel()
  │       ├── 检查错误类型
  │       ├── 检查 AutoBan 配置
  │       └── 判断是否为渠道级错误
  │
  ├── 异步禁用渠道 (如果需要)
  │   └── service.DisableChannel()
  │       ├── 更新渠道状态为禁用
  │       ├── 清除缓存
  │       └── 记录禁用原因
  │
  └── 保存错误日志到数据库
      └── model.RecordErrorLog()
```

### 2. 重试机制

```
shouldRetry(c, err, retryTimes)               # controller/relay.go:236
  判断条件:
  ├── err == nil → 不重试
  ├── IsChannelError(err) → 重试 (渠道级错误)
  ├── IsSkipRetryError(err) → 不重试
  ├── retryTimes <= 0 → 不重试
  ├── 指定了特定渠道 → 不重试
  ├── 状态码 429 (Too Many Requests) → 重试
  ├── 状态码 307 (Temporary Redirect) → 重试
  ├── 状态码 5xx (服务器错误) → 重试
  │   └── 但 504/524 超时不重试
  ├── 状态码 400/408 → 不重试
  └── 默认 → 重试
```

---

## 十一、核心文件清单

### 入口和路由
- `main.go` - 程序入口
- `router/main.go` - 路由主入口
- `router/relay-router.go` - 中继路由配置
- `router/api-router.go` - API 管理路由
- `router/web-router.go` - Web 前端路由

### 中间件
- `middleware/auth.go` - 认证中间件
- `middleware/distributor.go` - 渠道分发中间件
- `middleware/rate-limit.go` - 限流中间件
- `middleware/model-rate-limit.go` - 模型级限流
- `middleware/cors.go` - CORS 中间件
- `middleware/stats.go` - 统计中间件

### 控制器
- `controller/relay.go` - 中继控制器(核心)
- `controller/channel.go` - 渠道管理
- `controller/token.go` - Token 管理
- `controller/user.go` - 用户管理

### Relay 层
- `relay/relay_adaptor.go` - 适配器工厂
- `relay/compatible_handler.go` - 文本处理器
- `relay/image_handler.go` - 图像处理器
- `relay/audio_handler.go` - 音频处理器
- `relay/embedding_handler.go` - 嵌入向量处理器
- `relay/claude_handler.go` - Claude 处理器
- `relay/gemini_handler.go` - Gemini 处理器
- `relay/websocket.go` - WebSocket 处理器
- `relay/relay_task.go` - 任务处理器

### 渠道适配器
- `relay/channel/adapter.go` - 适配器接口定义
- `relay/channel/openai/` - OpenAI 适配器
- `relay/channel/claude/` - Claude 适配器
- `relay/channel/gemini/` - Gemini 适配器
- `relay/channel/ali/` - 阿里云适配器
- `relay/channel/baidu/` - 百度适配器
- ... (30+ 渠道)

### 辅助层
- `relay/common/relay_info.go` - RelayInfo 定义
- `relay/common/relay_utils.go` - 工具函数
- `relay/helper/price.go` - 价格计算
- `relay/helper/valid_request.go` - 请求验证
- `service/quota.go` - 配额管理
- `service/token_counter.go` - Token 计数
- `service/http_client.go` - HTTP 客户端

### 数据模型
- `model/channel.go` - 渠道模型
- `model/token.go` - Token 模型
- `model/user.go` - 用户模型
- `model/log.go` - 日志模型
- `model/task.go` - 任务模型

---

## 十二、总结

### 请求处理的核心流程:

1. **路由阶段**: 请求进入 → Gin 路由 → 匹配到对应的路由处理器
2. **中间件阶段**: Token 认证 → 权限验证 → 渠道选择 → 设置上下文
3. **控制器阶段**: 请求验证 → Token 计数 → 价格计算 → 预扣费
4. **Relay 阶段**: 获取适配器 → 转换请求格式 → 调用上游 API
5. **响应阶段**: 处理响应 → 转发给客户端 → 后扣费 → 记录日志

### 关键设计模式:

1. **适配器模式**: 统一不同 AI 服务商的 API 接口
2. **中间件链模式**: 请求经过多层中间件处理
3. **工厂模式**: 根据渠道类型创建对应的适配器
4. **策略模式**: 不同的请求类型使用不同的处理策略

### 核心特性:

1. **多渠道支持**: 支持 30+ AI 服务提供商
2. **自动重试**: 失败时自动切换渠道重试
3. **配额管理**: 预扣费 + 后扣费机制
4. **限流保护**: 多级限流(全局、用户、模型)
5. **错误处理**: 完善的错误处理和日志记录
6. **缓存优化**: Redis 缓存渠道信息,提高性能

---

*文档生成时间: 2025-10-09*
*项目版本: New API*
